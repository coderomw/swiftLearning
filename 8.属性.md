## 属性

1. 在swift中，跟实例相关的属性分为两大类
   - 存储属性
     - 类似于成员变量这个概念
     - 存储在实例的内存中
     - 结构体、类可以定义存储属性    而枚举只存储关联值和区分case的一个字节
     - 枚举不可以定义存储属性
   - 计算属性
     - 本质就是方法( 函数 )
     - 不占用实例的内存
     - 枚举、结构体、类都可以定义计算属性

### 存储属性

1. swift有明确规定: 在创建类、结构体的实例时, 必须为所有的存储属性设置一个合适的初始值
   - 可以在初始化器中为存储属性设置一个初始值
   - 可以分配一个默认的属性值作为属性定义的一部分

### 计算属性

1. set传入的新值默认叫newValue, 也可以自定义
2. 只读计算属性: 只有get, 没有set
3. 定义计算属性只能用var, 不能用let, 因为计算属性的值是可能发生变化的 (即使是只读计算属性, 有可能根据别的属性计算而来)
4. 枚举原始值rawValue的本质: 只读计算属性

### 延迟存储属性

1. 使用lazy可以定义一个延迟存储属性, 在第一次用到属性的时候才进行初始化
2. lazy属性必须是var, 不能是let
3. 因为let要求必须在实例的初始化方法完成之前就拥有值
4. 如果多条线程同时第一次访问lazy属性, 不能确保属性只被初始化一次
5. lazy属性要有初始值

注意点:

1. 当结构体包含一个延迟存储属性时, 只有var才能访问延迟存储属性, 因为延迟属性初始化的时候, 需要改变结构体的内存

### 属性观察器

1. 可以为非lazy的var存储属性设置属性观察器
2. willSet会传递新值, 默认叫newValue
3. didSet会传递旧值, 默认叫oldValue
4. 在初始化器中设置默认值不会触发willSet和didSet
5. 在属性定义时设置初始值也不会触发willSet和didSet ( 其实本质就是在初始化器中定义 )

### 属性观察器、计算属性的功能, 同样可以应用在全局变量、局部变量身上

### inout的本质

1. 如果实参有物理内存地址, 切没有设置属性观察器, 则直接将实参的内存地址传入函数 ( 实参进行引用传递 )
2. 如果实参是计算属性 或者 设置了属性观察器, 则采取Copy In Copy Out的做法
   - 调用该函数时, 先复制实参的值, 产生副本 [get]
   - 将副本的内存地址传入函数 (副本进行引用传递), 在函数内部可以修改副本的值
   - 函数返回后, 再将副本的值覆盖实参的值 [set]
3. inout的本质就是引用传递(地址传递)

### 类型属性

严格来说, 属性可以分为:

1. 实例属性: 只能通过实例去访问
   - 存储实例属性: 存储在实例的内存中, 每个实例都有一份
   - 计算实例属性
2. 类型属性: 只能通过类型去访问
   - 存储类型属性: 整个程序运行过程中, 就只有一份内存( 类似于全局变量 )
   - 计算类型属性
3. 可以通过 static 定义类型属性; 如果是类的话, 还可以用关键字class

### 类型属性细节

1. 不同于存储实例属性, 必须给存储类型属性设定初始值, 因为类型没有像实例那样的init初始化器来初始化存储属性
2. 存储类型属性默认就是lazy, 会在第一次使用的时候才初始化
3. 就算被多个线程同时访问, 保证只会初始化一次
4. 存储类型属性可以是let
5. 枚举类型也可以定义类型属性 ( 存储类型属性、计算类型属性 )

### 单例模式

```swift
public class FileManager {
    public static let shared = FileManager()
    private init () {}
}

var sharedManager = FileManager.shared
```

```swift
public class FileManager {
    public static let shared = {
        // ...
        // ...
        return FileManager()
    }
    private init () {}
}

var sharedManager = FileManager.shared
```



