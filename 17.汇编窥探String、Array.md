### 关于String

1. String实际存储的内容是字符的ASCII值, ASCII码表 [https://www.ascii-code.com/](https://www.ascii-code.com/)

2. 一个String变量占用16个字节, 当字符串的长度小于等于15时, 字符串就存储在当前String变量的内存中, 其中有一个字节,例如下方的0xea, 其中a代表字符串的长度是10, e代表存储类型, 是存储在字符变量内存中的

   ```swift
   var v1 = "0123456789"
   print(Mems.memStr(ofVal: &v1))
   //0x3736353433323130 
   //0xea00000000003938
   ```

3. 当使用append拼接字符串时, 如果拼接完的字符串长度还是小于等于15, 那么还是会存在字符变量的内存中; 当字符串长度大于15时, 会开辟新的存储空间,如下方所示, 字符变量的后8个字节放着一个地址值, 指向真正存储字符ASCII码的地方, 前八个字节, 其中10代表字符串长度为16, 0xd的d代表存储类型

   ```swift
   var v1 = "0123456789ABCDEF"
   print(Mems.memStr(ofVal: &v1))
   //0xd000000000000010 
   //0x8000000100008010
   ```

4. 通过0x8000000100008010, 把高位的8去了, 0x0000000100008010 + 0x20 = 0x0000000100008030, 这个地址其实就是真正存储字符ASCII码的内存地址, 通过macho view可以看到, 是在( _TEXT, _cstring )段, 一般认为是常量区(代码段), 这一区域的数据时不能动态修改的.

   ```swift
   (lldb) x/10xg 0x0000000100008030
   0x100008030: 0x3736353433323130 0x4645444342413938
   0x100008040: 0x7365740033323100 0x0000000000003174
   0x100008050: 0x777339464374545f 0x3874736554746669
   0x100008060: 0x656469727265766f 0x365f4c5f545f5446
   0x100008070: 0x7200656c63726943 0x0000007375696461
   
   (lldb) x/10xg 0x0000000100008010
   0x100008010: 0xfe06e90000082b68 0xe90000084068ffff
   0x100008020: 0x00000068fffffdfc 0x0000fffffdf2e900
   0x100008030: 0x3736353433323130 0x4645444342413938
   0x100008040: 0x7365740033323100 0x0000000000003174
   0x100008050: 0x777339464374545f 0x3874736554746669
   ```



### dyld_stub_binder

1. 符号的延迟绑定通过dyld_stub_binder完成
2. 符号绑定, 调用动态库, swift系统库的时候, 编译时callq一个假的地址,这个地址绑定了真正调用的函数地址, 绑定一次之后就不再绑定了, 以后就直接调用真正的函数地址了

### Array内存

1. 一个Array变量占用8个字节, 存储这内存地址

   ```swift
   var array = [1, 2, 3, 4]
   print(Mems.size(ofVal: &array))//8
   print(Mems.memStr(ofVal: &array))//0x00000001005b9040
   ```

2. 这个内存地址指向堆空间的一段内存, 前面32个字节: 第二段的8个字节放着引用计数相关, 第三段的8个字节放着元素数量, 第四段的8个字节放着数组的容量; 32个字节后放的就是数组元素的内容

   ```swift
   (lldb) x/8xg 0x00000001005b9040
   0x1005b9040: 0x00007fff909f74d8 0x0000000000000002
   0x1005b9050: 0x0000000000000004 0x0000000000000008
   0x1005b9060: 0x0000000000000001 0x0000000000000002
   0x1005b9070: 0x0000000000000003 0x0000000000000004
   ```

   

