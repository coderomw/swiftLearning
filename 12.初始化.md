## 初始化

1. 类、结构体、枚举都可以定义初始化器
2. 类有两中初始化器: 指定初始化器、便捷初始化器
   - 每个类至少有一个指定初始化器, 指定初始化器是类的主要初始化器
   - 默认初始化器总是类的指定初始化器
   - 类偏向于少量指定初始化器, 一个类通常只有一个指定初始化器
3. 初始化器的相互调用规则
   - 指定初始化器必须从它的直系父类调用指定初始化器
   - 便捷初始化器必须从相同的类里调用另一个初始化器
   - 便捷初始化器最终必须调用一个指定初始化器

4. 这一套规则保证了, 使用任意初始化器, 都可以完整地初始化实例

### 两段式初始化

Swift为了保证编码安全, 保证初始化过程的安全, 设定了两段式初始化、安全检查

1. 第一阶段: 初始化所有存储属性
   - 外层调用指定\便捷初始化器
   - 分配内存给实例, 但未初始化
   - 指定初始化器确保当前类定义的存储属性都初始化
   - 指定初始化器调用父类的初始化器, 不断向上调用, 形成初始化器链
2. 第二阶段: 设置新的存储属性值
   - 从顶部初始化器往下, 链中的每一个指定初始化器都有机会进一步订制实例
   - 初始化器现在能够使用self ( 访问、修改它的属性, 调用它的实例方法等等 ) 
   - 最终, 链中任何便捷初始化器都有机会订制实例以及使用self

### 安全检查

1. 指定初始化器必须保证在调用父类初始化器前, 其所在类定义的所有存储属性都要初始化完成
2. 指定初始化器必须先调用父类初始化器, 然后才能为继承的属性设置新值
3. 便捷初始化器必须先调用同类中的其它初始化器, 然后再为任意属性设置新值
4. 初始化器在第一阶段初始化完成之前, 不能调用任何实例方法、不能读取任何实例属性的值, 也不能引用self
5. 直到第一阶段结束, 实例才算完全合法

### 重写

1. 当重写父类的指定初始化器时, 必须加上override ( 即使子类的实现是便捷初始化器 )
2. 如果子类写了一个匹配父类便捷初始化器的初始化器, 不用加上override
   - 因为父类的便捷初始化器永远不会通过子类直接调用, 因此, 严格来说, 子类无法重写父类的便捷初始化器

### 自动继承规则

1. 如果子类没有定义任何指定初始化器, 它会自动继承父类所有的指定初始化器
2. 如果子类提供了父类所有指定初始化器的实现 ( 要么通过方式1继承, 要么重写 ), 那么子类自动继承所有的父类便捷初始化器
3. 就算子类添加了更多的便捷初始化器, 这些规则仍然适用
4. 子类以便捷初始化器的形式重写父类的指定初始化器, 也可以作为满足规则2的一部分

### required

1. 用required修饰指定初始化器, 表面其所有子类都必须实现该初始化器 ( 通过继承或者重写实现 )
2. 如果子类重写了required初始化器, 也必须加上required, 不用加override

### 属性观察器

1. 父类的属性观察器在它自己的初始化器中赋值不会触发属性观察器, 但在子类的初始化器中赋值会触发属性观察器

### 可失败初始化器

1. 类、结构体、枚举都可以使用init?定义可失败初始化器

2. 可失败初始化器举例

   ```swift
   var num = Int("123");
   public init?(_ description: String)
   ```

   ```swift
   enum Answer : Int {
   	case wrong, right
   }
   var an = Answer(rawValue: 1)
   ```

3. 不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器

4. 可以用init!定义隐式解包的可失败初始化器

5. 可失败初始化器可以调用非可失败初始化器, 非可失败初始化器调用可失败初始化器需要进行解包

6. 如果初始化器调用一个可失败初始化器致初始化失败, 那么整个初始化过程都失败, 并且之后的代码都停止执行

7. 可以用一个非失败初始化重写一个可失败初始化器, 但反过来不行

### 反初始化器 (deinit )

1. deinit叫做反初始化器, 类似于C++的析构函数, OC中的dealloc方法
2. 当类的实例对象被释放内存时, 就会调用实例对象的deinit方法
3. deinit不接受任何参数, 不能写小括号, 不能自行调用
4. 父类的deinit能被子类继承
5. 子类的deinit实现执行完毕后会调用父类的deinit

